# Потоки

> Вольный перевод документации [Threads](https://www.sfml-dev.org/tutorials/2.5/system-thread.php#what-is-a-thread)

## Что такое поток?

Большинство из вас уже должно знать, что такое поток, однако вот небольшое объяснение для кого эта концепция неизвестна.

Поток - это в основном последовательность инструкций, которые выполняются параллельно другим потокам. Каждая программа состоит как минимум из одного потока: основного, в котором выполняется ваша `main()` функция. Программы, которые используют только основной поток, являются однопоточными, если вы добавляете один или несколько потоков, они становятся многопоточными .

Короче говоря, потоки - это способ делать несколько вещей одновременно. Это может быть полезно, например, для отображения анимации и реакции на ввод пользователя при загрузке изображений или звуков. Потоки также широко используются в сетевом программировании, чтобы ждать получения данных, продолжая обновлять и рисовать приложение.


## Потоки из библиотеки SFML или std::thread?

В крайней верисии от 2011 г. стандартная библиотека `C++` предоставляет набор классов для потоковой передачи [classes for threading (en)](https://en.cppreference.com/w/cpp/thread). На момент написания SFML не был написан стандарт `C++11` и не было стандартного способа создания потоков. Когда был выпущен SFML 2.0, все еще было много компиляторов, которые не поддерживали этот новый стандарт.

Если вы работаете с компиляторами, которые поддерживают новый стандарт и его бибиотку потоков (`<thread>`), забудьте о классах потоков SFML - так будет намного лучше. Но если вы работаете с компилятором до 2011 года или планируете распространять свой код и хотите, чтобы он был полностью переносимым, классы потоковой передачи SFML - хорошее решение.

## Создание потока с помощью SFML

Хватит разговоров, давайте посмотрим код. Класс, который позволяет создавать потоки в SFML, есть [sf::Thread (en)[https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php], и вот как он выглядит в действии:

```
#include <SFML/System.hpp>
#include <iostream>

void func()
{
    // функция запускается когда вызывается thread.launch()
    for (int i = 0; i < 10; ++i)
        std::cout << "\tПервый поток" << std::endl;
}

int main()
{
    setlocale(LC_ALL, "Rus");

    // создание потока, используя функцию func() как точку входа (функция будет работать в другом потоке)
    sf::Thread thread(&func);

    // запуск потока
    thread.launch();

    // основной поток продолжает работу ...

    for (int i = 0; i < 10; ++i)
        std::cout << "Главный поток" << std::endl;

    return 0;
}
```

В этом коде оба потока `main` и `func` выполняются параллельно, после того как был вызван `thread.launch()`. В результате текст из обеих функций должен смешиваться в консоли (_в русской локализации скриншот будет немного другим_ - прим. переводчика).

![](https://www.sfml-dev.org/tutorials/2.5/images/system-thread-mixed.png)

Точка входа в поток, т.е. функция, которая будет запускаться при запуске потока, должна быть передана конструктору `sf::Thread`. `sf::Thread` пытается быть гибким и принимать широкий спектр точек входа: функции, не являющиеся членами, или функции-члены класса, с аргументами или без них, функторы и т.д. В приведенном выше примере показано, как использовать функцию, не являющуюся членом класса. Ниже представлено несколько других примеров.

- Функция, не являющаяся членом класса, с одним аргументом:

```
void func(int x)
{
}

sf::Thread thread(&func, 5);
```

- Функция-член класса:

```
class MyClass
{
public:
    void func()
    {
    }
};

MyClass object;
sf::Thread thread(&MyClass::func, &object);
```

- Функтор (функция-объект):

```
struct MyFunctor
{
    void operator()()
    {
    }
};

sf::Thread thread(MyFunctor());
```

Последний пример, в котором используются функторы, является наиболее мощным, поскольку он может принимать любой тип функтора и, следовательно, обеспечивает `sf::Thread` совместимость со многими типами функций, которые не поддерживаются напрямую. Эта функция особенно интересна с лямбдами C++11 или std::bind.

```
// с лямбдами
sf::Thread thread([](){
    std::cout << "I am in thread!" << std::endl;
});
```

```
// с std::bind
void func(std::string, int, double)
{
}

sf::Thread thread(std::bind(&func, "hello", 24, 0.5));
```
Если вы хотите использовать `sf::Thread` внутри класса, не забывайте, что у него нет конструктора по умолчанию. Следовательно, вы должны инициализировать его прямо в списке инициализации конструктора:

```
class ClassWithThread
{
public:

    ClassWithThread()
    : m_thread(&ClassWithThread::f, this)
    {
    }

private:

    void f()
    {
        ...
    }

    sf::Thread m_thread;
};
```

Если вам действительно нужно создать свой `sf::Thread` экземпляр после создания объекта-владельца, вы также можете отложить его создание, динамически разместив его в куче.


... некоторая часть не переведена ..
